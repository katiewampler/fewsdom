---
title: "Package Reminders"
author: "Katie Wampler"
date: "2022-12-24"
output: pdf_document
---
Formatting rules 
-doc should be lowercase in functions, capital in documentation 
-eem should be lowercase in functions, EEMs in documentation 
-parameters should start with lowercase, no periods at end 
-function descriptions should be in sentence case 
-descriptions should have sentence structure and periods
-arguments should be in same order as documentation and function
-functions in documentation should be in single quotes


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
to do:: save eems data as r object and .csv 


```


## THINGS TO DO 

4. clean up documentation, similar arguments 
6. add examples to functions


#Work Flow 

4. Work towards making sections of the script into functions 
5. Make a very simple script that does everything. Write to loop through files so you can easily process everything the same way. 
6. Create functions for combining individual files
7. Export package for use on github 
8. Start on personal package with things I use a lot.  


## CODE THAT I DON'T WANT TO DUMP YET 
#' Interpolates Missing Values in EEM Data *CURRENTLY NOT IN USE
#'
#' Modified from 'eem_interp' function in staRdom package to include the option of interpolating
#' a single eem or an eem list
#'
# @importFrom parallel detectCores
# @importFrom doParallel registerDoParallel
# @importFrom zoo na.approx
# @importFrom MBA mba.points
# @importFrom tidyr gather
# @import foreach

#'
#' @param data An object of class eemlist or eem.
#' @param cores	 specify number of cores for parallel computation
#' @param type numeric 0 to 4 or TRUE which resembles type 1
#' @param verbose logical, whether more information on calculation should be provided
#' @param nonneg logical, whether more information on calculation should be provided
#' @param extend logical, whether data is extrapolated using type 1
#' @noRd
```{r}

eem_interp2 <- function (data, cores = parallel::detectCores(logical = FALSE),
                         type = TRUE, verbose = FALSE, nonneg = TRUE, extend = FALSE){
  cl <- makeCluster(spec = min(cores, length(data)), type = "PSOCK")
  doParallel::registerDoParallel(cl)
  if (verbose) {
    cat("interpolating missing data in", length(data),
        "EEMs", fill = TRUE)
  }
  if(class(data) == "eemlist"){
    eem_list <- foreach::foreach(i = 1:length(data)) %dopar% {
      eem <- data[[i]]
      if (type == 4) {
        eem$x <- cbind(zoo::na.approx(eem$x), t(zoo::na.approx(t(eem$x)
        ))) %>% array(c(nrow(eem$x), ncol(eem$x),
                        2)) %>% apply(1:2, mean, na.rm = TRUE)
      }
      if (type == 1 | type == TRUE) {
        x <- eem$x %>% data.frame() %>% `colnames<-`(eem$ex) %>%
          `rownames<-`(eem$em) %>% mutate(em = eem$em) %>%
          tidyr::gather("ex", "z", -em) %>% mutate_all(as.numeric)
        x2 <- x %>% filter(!is.na(z))
        x3 <- MBA::mba.points(xyz = x2 %>% select(em, ex,
                                                  z), xy.est = expand.grid(em = eem$em, ex = eem$ex),
                              verbose = verbose, extend = extend)
        eem$x[is.na(eem$x)] <- x3$xyz.est[, 3] %>% matrix(nrow = nrow(eem$x),
                                                          ncol = ncol(eem$x)) %>% .[is.na(eem$x)]
      }
      if (type == 2) {
        x1 <- try(eem$x %>% apply(1, function(row) pracma::pchip(xi = eem$ex[!is.na(row)],
                                                                 yi = row %>% na.omit(), x = eem$ex)) %>%
                    t(), silent = TRUE)
        x2 <- try(eem$x %>% apply(2, function(col) pracma::pchip(xi = eem$em[!is.na(col)],
                                                                 yi = col %>% na.omit(), x = eem$em)), silent = TRUE)
        if (inherits(x1, "try-error") & inherits(x2,
                                                 "try-error"))
          warning(eem$sample, " could not be interpolated!")
        if (inherits(x1, "try-error"))
          x1 <- matrix(NA, nrow(eem$x), ncol(eem$x))
        if (inherits(x2, "try-error"))
          x2 <- matrix(NA, nrow(eem$x), ncol(eem$x))
        eem$x <- cbind(x1, x2) %>% array(c(nrow(x1), ncol(x2),
                                           2)) %>% apply(1:2, mean, na.rm = TRUE)
      }
      if (type == 3) {
        eem$x <- eem$x %>% apply(2, function(col) pracma::pchip(xi = eem$em[!is.na(col)],
                                                                yi = col %>% na.omit(), x = eem$em))
      }
      if (type == 0) {
        eem$x[is.na(eem$x)] <- 0
      }
      if (nonneg)
        eem$x[eem$x < 0] <- 0
      eem
    }
    stopCluster(cl)
    class(eem_list) <- "eemlist"
    eem_list

  }else if(class(data) =="eem"){
    eem <- data
    if (type == 4) {
      eem$x <- cbind(zoo::na.approx(eem$x), t(zoo::na.approx(t(eem$x)))) %>% array(c(nrow(eem$x), ncol(eem$x),
                                                                                     2)) %>% apply(1:2, mean, na.rm = TRUE)
    }
    if (type == 1 | type == TRUE) {
      x <- eem$x %>% data.frame() %>% `colnames<-`(eem$ex) %>%
        `rownames<-`(eem$em) %>% mutate(em = eem$em) %>%
        tidyr::gather("ex", "z", -em) %>% mutate_all(as.numeric)
      x2 <- x %>% filter(!is.na(z))
      x3 <- MBA::mba.points(xyz = x2 %>% select(em, ex,
                                                z), xy.est = expand.grid(em = eem$em, ex = eem$ex),
                            verbose = verbose, extend = extend)
      eem$x[is.na(eem$x)] <- x3$xyz.est[, 3] %>% matrix(nrow = nrow(eem$x),
                                                        ncol = ncol(eem$x)) %>% .[is.na(eem$x)]
    }
    if (type == 2) {
      x1 <- try(eem$x %>% apply(1, function(row) pracma::pchip(xi = eem$ex[!is.na(row)],
                                                               yi = row %>% na.omit(), x = eem$ex)) %>%
                  t(), silent = TRUE)
      x2 <- try(eem$x %>% apply(2, function(col) pracma::pchip(xi = eem$em[!is.na(col)],
                                                               yi = col %>% na.omit(), x = eem$em)), silent = TRUE)
      if (inherits(x1, "try-error") & inherits(x2,
                                               "try-error"))
        warning(eem$sample, " could not be interpolated!")
      if (inherits(x1, "try-error"))
        x1 <- matrix(NA, nrow(eem$x), ncol(eem$x))
      if (inherits(x2, "try-error"))
        x2 <- matrix(NA, nrow(eem$x), ncol(eem$x))
      eem$x <- cbind(x1, x2) %>% array(c(nrow(x1), ncol(x2),
                                         2)) %>% apply(1:2, mean, na.rm = TRUE)
    }
    if (type == 3) {
      eem$x <- eem$x %>% apply(2, function(col) pracma::pchip(xi = eem$em[!is.na(col)],
                                                              yi = col %>% na.omit(), x = eem$em))
    }
    if (type == 0) {
      eem$x[is.na(eem$x)] <- 0
    }
    if (nonneg)
      eem$x[eem$x < 0] <- 0
    eem
  }

}

```

